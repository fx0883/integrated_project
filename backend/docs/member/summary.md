# 用户系统拆分总结

## 拆分目标

将现有的单一User模型拆分为两个独立的模型：
1. **User模型**：只包含超级管理员和租户管理员，不包含父子账号关系
2. **Member模型**：只包含普通成员，保留父子账号关系

## 设计方案

采用**共享基类方案**，创建一个抽象基类`BaseUserModel`，User和Member模型继承该基类。这种方案的优势在于：
- 减少代码重复
- 统一认证机制
- 简化权限控制
- 便于未来扩展

## 主要组件

### 模型设计

1. **BaseUserModel（抽象基类）**
   - 继承自Django的AbstractUser
   - 包含共有字段：基本用户信息、租户关联、状态标记等
   - 提供共有方法：软删除、显示名称等

2. **User模型（管理员用户）**
   - 继承自BaseUserModel
   - 特有字段：is_admin、is_super_admin
   - 特有方法：is_tenant_admin、display_role等

3. **Member模型（普通成员）**
   - 继承自BaseUserModel
   - 特有字段：parent（父账号关系）、is_member
   - 特有方法：is_sub_account、display_role等

### 认证系统

1. **自定义认证后端**
   - 支持两种用户模型的认证
   - 在两个模型中查找用户并验证密码

2. **JWT令牌定制**
   - 在令牌中包含用户类型信息
   - 根据用户类型从对应模型获取用户实例

3. **用户获取中间件**
   - 从JWT令牌中获取当前用户
   - 根据用户类型从对应模型获取用户实例

### API设计

1. **认证相关API**
   - 统一的登录视图，支持两种用户类型
   - 令牌刷新、登出、密码修改等功能

2. **用户管理API**
   - 管理员用户的CRUD操作
   - 当前用户信息获取

3. **成员管理API**
   - 普通成员的CRUD操作
   - 子账号管理功能

### 数据迁移

1. **迁移策略**
   - 保留原始数据
   - 分阶段迁移
   - 先结构后数据
   - 维护外键关系

2. **迁移步骤**
   - 准备工作：创建备份、冻结功能
   - 模型结构迁移：创建新模型
   - 数据迁移：将数据迁移到新模型
   - 更新外键关系：维护引用完整性
   - 更新代码和配置：部署新代码
   - 测试和验证：确保系统正常运行

## 实现挑战与解决方案

### 1. 认证系统适配

**挑战**：现有认证系统基于单一User模型，需要支持两种用户模型。

**解决方案**：
- 创建自定义认证后端，在两个模型中查找用户
- 在JWT令牌中添加用户类型信息
- 使用中间件根据令牌中的用户类型获取用户实例

### 2. 外键关系维护

**挑战**：系统中多个模型与User模型存在外键关系，需要维护这些关系。

**解决方案**：
- 创建专门的外键更新迁移脚本
- 根据用户类型将外键指向对应的模型
- 全面测试外键关系的完整性

### 3. 权限控制

**挑战**：需要基于两种用户模型实现权限控制。

**解决方案**：
- 创建自定义权限类，支持两种用户模型
- 使用`isinstance()`检查用户类型
- 实现细粒度的权限控制逻辑

### 4. 数据迁移

**挑战**：需要将现有用户数据迁移到两个不同的模型，同时保持数据完整性。

**解决方案**：
- 创建详细的数据迁移计划
- 使用Django迁移框架的RunPython操作
- 分阶段执行迁移，每个阶段后验证数据完整性
- 准备回滚策略，以应对迁移问题

## 未来优化方向

1. **性能优化**
   - 优化认证过程中的数据库查询
   - 考虑使用缓存减少数据库访问

2. **API版本控制**
   - 为API添加版本控制，以便将来进行兼容性更改

3. **权限系统扩展**
   - 实现更细粒度的权限控制
   - 支持基于角色的访问控制

4. **多因素认证**
   - 为两种用户模型添加多因素认证支持

5. **审计日志**
   - 记录用户活动和系统变更
   - 支持合规性和安全审计

## 总结

通过将单一User模型拆分为User和Member两个模型，我们实现了以下目标：

1. **清晰的职责分离**：管理员用户和普通成员有明确的模型边界
2. **简化的权限控制**：基于用户类型的权限控制更加直观
3. **灵活的扩展性**：两个模型可以独立演化，满足不同的业务需求
4. **优化的数据结构**：去除了不必要的字段和关系，提高了数据库效率

这种设计为系统提供了更好的可维护性和可扩展性，同时保持了现有功能的完整性。 